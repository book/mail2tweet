#!/usr/bin/perl
use strict;
use warnings;
use Encode qw( decode );
use Email::MIME;
use Net::Twitter;
use YAML::Tiny qw( LoadFile DumpFile Dump );
use Mail::IMAPClient;
use Getopt::Long;
use Regexp::Common;
use Scalar::Util 'blessed';
use List::Util 'min';
use File::Spec;
use Pod::Usage;
use DateTime;

# command-line options
GetOptions( \my %option, 'config=s', 'dry-run', 'help', 'manual' )
    or pod2usage( -verbose => 1, -exit => 2 );

# simple on-line help
pod2usage( -verbose => 1 ) if $option{help};
pod2usage( -verbose => 2 ) if $option{manual};

# read config
my $config = LoadFile( $option{config} );

### Step 1: get the message

# start IMAP connection
my $imap = Mail::IMAPClient->new(
    Server   => $config->{imap}{server},
    Port     => $config->{imap}{port},
    User     => $config->{imap}{user},
    Password => $config->{imap}{password},
    Ssl      => $config->{imap}{ssl},
    Uid      => 1,
) or die "$@\n";

# select the folder in which to search
$imap->select( $config->{mail}{folder} )
    or die "Select '$config->{mail}{folder}' error: ", $imap->LastError, "\n";

# perform the search for interesting messages
my @search = (
    SINCE => $imap->Rfc3501_date( $config->{mail}{last} ||= 0 ),
    @{ $config->{mail}{search} },
);
my $msgs = $imap->search( @search )
    or die "Search '@{ $config->{mail}{search} }' error: ", $imap->LastError,
    "\n";

# nothing found
exit if !@$msgs;

# pick up the selected messages dates
my $date = $imap->fetch_hash( $msgs, "INTERNALDATE" );

# and format them in a sortable way
$_->{epoch} = epoch_Rfc3501( $_->{INTERNALDATE} ) for values %$date;

# pick up the oldest message
my ($oldest);
$date->{$_}{epoch} > $config->{mail}{last}
    and !$oldest || $date->{$_}{epoch} < $date->{$oldest}{epoch}
    and $oldest = $_
    for keys %$date;

# nothing recent
exit if !$oldest;

# has this message been \Seen?
my $seen = grep { /\\Seen/ } $imap->flags( $oldest );

# and save it
my $email = $imap->message_string( $oldest );

### Step 2: munge the email
$email = Email::MIME->new($email);

# get the charset
my ($charset) = $email->header('content-type') =~ /charset=([^\s;]+)/;
$charset ||= 'iso-8859-1';    # is that the right default?
$charset =~ y/'"//d;
$charset = lc $charset;

# Windows is always a special case
$charset = 'cp1252' if $charset eq 'windows-1252';

# get the subject, properly decoded from whatever encoding
my $raw_subject = $email->header('subject');
my $subject = $charset eq 'utf-8'
    ? $raw_subject
    : decode( $charset, $raw_subject );

# get rid of uninteresting stuff
my @remove = ( @{ $config->{cleanup}{subject} || [] }, '^\s*|\s*$' );
$subject =~ s/$_// for @remove;

# get the first URL
my @url;
for my $part ( $email->parts() ) {
    next if $part->content_type !~ m{text/plain};    # skip non text parts
    my $body = $part->body;
    $body =~ s/$_//mg for @{ $config->{cleanup}{body} || [] };
    my $sign;
    @url = map { /($RE{URI}{HTTP}{-scheme=>'https?'})/g }   # catch all HTTP URL
      grep !/^[>:]/,                                        # ignore quotes
      grep { /^-- ?$/ and $sign = 1; !$sign }               # ignore signature
      split /[\n\r]+/, $body;                               # line by line
    last if @url;
}
goto DONE if !@url;    # goto next email

# add the hashtags
$subject =~ s{\b(@{[join '|', map quotemeta, @{$config->{twitter}{tags}}]})\b}
             {#$1}gi
    if @{ $config->{twitter}{tags} || [] };

### Step 3: Profit!^W^WSend the tweet

# create the message
my $message = "$subject - $url[0]";

if ( $option{'dry-run'} ) {    # just checking
    print "$message\n";
}
else {                         # tweet it!
    my $twit = Net::Twitter->new(
        traits              => [qw/API::REST OAuth/],
        consumer_key        => $config->{twitter}{consumer_key},
        consumer_secret     => $config->{twitter}{consumer_secret},
        access_token        => $config->{twitter}{access_token},
        access_token_secret => $config->{twitter}{access_token_secret},
    );

    my $delay = $config->{twitter}{retry} ||= 30;
    while (1) {    # keep trying
        if ( my $result = eval { $twit->update($message); } ) {
            last;
        }
        else {
            my $err = $@;
            die $err unless blessed $err and $err->isa('Net::Twitter::Error');
            my $error = sprintf '%s (%d %s)', $err->error, $err->code,
                $err->message;
            if ( $err->code !~ /^(?:403|2..)$/ )
            {   # network error (403 means refused by Twitter)
                $delay = min $delay, 1800;
                warn "$error - will retry in $delay seconds\n";
                sleep $delay;
                $delay *= 2;
            }
            else { # other error
                die "$message\n$error\n";
            }
        }
    }
}

DONE:

# leave it not \Seen if it wasn't
$imap->unset_flag( "\\Seen", $oldest )
  or warn "Could not unset_flag: $@\n"
  if !$seen;

# save the updated configuration
$config->{mail}{last} = $date->{$oldest}{epoch};
DumpFile( $option{config}, $config ) if !$option{'dry-run'};

exit 0;    # success

# small helper function
BEGIN {
    my @date_month = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
    my %month_by_name;
    @month_by_name{@date_month} = 1 .. @date_month;

    # should probably use DateTime::Format::RFC3501
    sub epoch_Rfc3501 {
        my ($internal) = @_;

        # 20-Sep-2010 14:25:53 +0200
        $internal =~ /^([ ]\d|\d{2})-([A-Z][a-z]{2})-(\d{4}) # date
           [ ](\d{2}):(\d{2}):(\d{2})                        # time
           [ ]([+-]\d{4})                                    # tz
        /x or die "Bad internal date: $internal";

        return DateTime->new(
            year      => 0 + $3,
            month     => $month_by_name{$2},
            day       => 0 + $1,
            hour      => 0 + $4,
            minute    => 0 + $5,
            second    => 0 + $6,
            time_zone => $7,
        )->epoch;
    }
}

__END__

=head1 NAME

mail2tweet - tweets subject and first link from an email

=head1 SYNOPSIS

    mail2tweet

    # everything of notice happens in the config file:
    ---
    cleanup:
      subject:
        - '^(?:(?i:Fwd|Re): *)*'
      body:
        - 'http://www.example.com/'
    imap:
      password: S3kr3t
      port: 1234
      server: localhost
      uid: 1
      ssl: 1
      user: example.user
    mail:
      folder: INBOX
      last: 1314777803
      search:
        - HEADER
        - x-list
        - funny_link
    twitter:
      tags:
        - perl
        - twitter
      access_token: 371430037-BIy72xkX0DVYroro1MKhyhJDz18BN7C69Zoyt0rO
      access_token_secret: 1zP21Si6ZG5IX1gsCf2tHk7JqTixyu2b1gJ27eT764
      consumer_key: jhBlwVmoKxD6Tol5nrSKA
      consumer_secret: gim30k5hBgIBfIrWodRn7dy4iZV2H3P5BKqKGxZOo

=head1 DESCRIPTION

B<mail2tweet> will connect (using SSL if the C<ssl> key is true) to the
IMAP server defined in the C<imap> key of the configuration file, open
the folder defined in the C<mail> section, run the optional C<search>
and get the oldest email that was received after the epoch
stored in the C<last> key.

It will then generate a tweet based on the subject line and the first
URL found in the email.

The subject line can be "cleaned up" using the regular expressions
listed in the C<cleanup> configuration keys to remove matching text
from the I<subject> and I<body> of the email.

Only the messages parts with content-type C<text/plain> will be
scanned for URL. Quoted email text (lines starting with C<< > >>, C<:>)
will be ignored.

Keywords listed in the C<twitter.tags> configuration key will be
highlighted as hashtags (using the C<#> character).

URL are not shortened, since Twitter will automatically shorten long
URL using its C<t.co> service.

If a matching email is found, after tweeting it the configuration file
is then rewritten to update the C<mail.last> key.

=head1 AUTHOR

Philippe Bruhat (BooK), C<< <book at cpan.org> >>

=head1 COPYRIGHT

Copyright 2011-2012 Philippe Bruhat (BooK), all rights reserved.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
